//! iii configuration file generator

use crate::runtime::check::Language;
use anyhow::{Context, Result};
use std::path::Path;
use tokio::fs;

/// Default port configurations
const DEFAULT_STREAMS_PORT: u16 = 31112;
const DEFAULT_API_PORT: u16 = 31113;
const DEFAULT_LOG_LEVEL: &str = "debug";

/// Supported JavaScript runtimes in order of preference
const JS_RUNTIMES: &[(&str, &str)] = &[
    ("bun", "bun run --enable-source-maps index-production.js"),
    ("node", "node --enable-source-maps index-production.js"),
];

/// Detect the available JavaScript runtime
fn detect_js_runtime() -> &'static str {
    for (runtime, command) in JS_RUNTIMES {
        if std::process::Command::new(runtime)
            .arg("--version")
            .output()
            .is_ok_and(|o| o.status.success())
        {
            return command;
        }
    }
    // Default to bun if nothing detected (will fail at runtime with helpful error)
    JS_RUNTIMES[0].1
}

/// Configuration module template
struct ModuleConfig {
    comment: &'static str,
    class: &'static str,
    config: String,
}

impl ModuleConfig {
    fn to_yaml(&self) -> String {
        format!(
            "  # {}\n  - class: {}\n    config:\n{}",
            self.comment, self.class, self.config
        )
    }
}

/// Generate an iii configuration file for the project
pub fn generate_config(project_dir: &Path, selected_languages: &[Language]) -> String {
    let node_modules_path = project_dir.join("node_modules");
    let venv_path = project_dir.join(".venv");

    let has_python = selected_languages.contains(&Language::Python);
    let has_js_ts = selected_languages
        .iter()
        .any(|l| matches!(l, Language::TypeScript | Language::JavaScript));

    let mut modules: Vec<ModuleConfig> = Vec::new();

    // Build exec module config
    let mut exec_config = String::new();
    exec_config.push_str("      exec:\n");
    exec_config.push_str(&format!("        - {}\n", detect_js_runtime()));

    if has_js_ts || has_python {
        exec_config.push_str("\n      # Runtime environment paths\n");
        exec_config.push_str("      env:\n");

        if has_js_ts {
            exec_config.push_str(&format!(
                "        NODE_PATH: \"{}\"\n",
                node_modules_path.display()
            ));
        }

        if has_python {
            exec_config.push_str(&format!(
                "        VIRTUAL_ENV: \"{}\"\n",
                venv_path.display()
            ));
            exec_config.push_str(&format!(
                "        PYTHONPATH: \"{}/lib/python3.11/site-packages\"\n",
                venv_path.display()
            ));
        }
    }

    modules.push(ModuleConfig {
        comment: "Main application execution",
        class: "modules::shell::ExecModule",
        config: exec_config,
    });

    // Stream module
    modules.push(ModuleConfig {
        comment: "Real-time data streams",
        class: "modules::streams::StreamModule",
        config: format!(
            "      port: {}\n\
             \x20     adapter:\n\
             \x20       class: adapters::kv_store::KvStore\n\
             \x20       config:\n\
             \x20         storage_type: in_memory\n",
            DEFAULT_STREAMS_PORT
        ),
    });

    // REST API module
    modules.push(ModuleConfig {
        comment: "REST API endpoints",
        class: "modules::api::RestApiModule",
        config: format!(
            "      port: {}\n\
             \x20     cors:\n\
             \x20       enabled: true\n\
             \x20       allow_origins:\n\
             \x20         - \"*\"\n",
            DEFAULT_API_PORT
        ),
    });

    // Logging module
    modules.push(ModuleConfig {
        comment: "Logging configuration",
        class: "modules::observability::LoggingModule",
        config: format!(
            "      level: {}\n\
             \x20     adapter:\n\
             \x20       class: adapters::logging::FileLogger\n\
             \x20       config:\n\
             \x20         path: ./logs\n\
             \x20         format: json\n",
            DEFAULT_LOG_LEVEL
        ),
    });

    // Build final config
    let mut config = String::new();
    config.push_str("# iii configuration for Motia project\n");
    config.push_str("# Generated by motia-cli\n\n");
    config.push_str("modules:\n");

    for (i, module) in modules.iter().enumerate() {
        config.push_str(&module.to_yaml());
        if i < modules.len() - 1 {
            config.push('\n');
        }
    }

    config
}

/// Write the iii configuration to a file
pub async fn write_config(project_dir: &Path, selected_languages: &[Language]) -> Result<()> {
    let config_content = generate_config(project_dir, selected_languages);
    let config_path = project_dir.join("iii.yaml");

    fs::write(&config_path, config_content)
        .await
        .with_context(|| format!("Failed to write iii config to {}", config_path.display()))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_config_typescript_only() {
        let dir = PathBuf::from("/test/project");
        let languages = vec![Language::TypeScript];

        let config = generate_config(&dir, &languages);

        assert!(config.contains("index-production.js"));
        assert!(config.contains("NODE_PATH"));
        assert!(!config.contains("VIRTUAL_ENV"));
    }

    #[test]
    fn test_generate_config_with_python() {
        let dir = PathBuf::from("/test/project");
        let languages = vec![Language::TypeScript, Language::Python];

        let config = generate_config(&dir, &languages);

        assert!(config.contains("NODE_PATH"));
        assert!(config.contains("VIRTUAL_ENV"));
        assert!(config.contains("PYTHONPATH"));
    }

    #[test]
    fn test_generate_config_has_default_ports() {
        let dir = PathBuf::from("/test/project");
        let languages = vec![Language::TypeScript];

        let config = generate_config(&dir, &languages);

        assert!(config.contains(&format!("port: {}", DEFAULT_STREAMS_PORT)));
        assert!(config.contains(&format!("port: {}", DEFAULT_API_PORT)));
    }

    #[test]
    fn test_detect_js_runtime_returns_valid_command() {
        let runtime = detect_js_runtime();
        assert!(runtime.contains("index-production.js"));
    }
}
