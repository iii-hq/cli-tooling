//! iii configuration file generator

use crate::runtime::check::Language;
use anyhow::{Context, Result};
use std::path::Path;
use tokio::fs;

/// Default port configurations
const DEFAULT_STREAMS_PORT: u16 = 31112;
const DEFAULT_API_PORT: u16 = 31113;
const DEFAULT_LOG_LEVEL: &str = "debug";

/// Generate an iii configuration file for the project
pub fn generate_config(
    project_dir: &Path,
    selected_languages: &[Language],
) -> String {
    let node_modules_path = project_dir.join("node_modules");
    let venv_path = project_dir.join(".venv");

    let has_python = selected_languages.contains(&Language::Python);
    let has_js_ts = selected_languages
        .iter()
        .any(|l| matches!(l, Language::TypeScript | Language::JavaScript));

    let mut config = String::new();

    config.push_str("# iii configuration for Motia project\n");
    config.push_str("# Generated by motia-cli\n\n");

    config.push_str("modules:\n");

    // TODO: Templatize this, this code is not sustainable
    // ExecModule for running the bundled Motia application
    config.push_str("  # Main application execution\n");
    config.push_str("  - class: modules::shell::ExecModule\n");
    config.push_str("    config:\n");
    config.push_str("      exec:\n");
    // TODO: Autodetect runtimes (node, python, etc.)
    config.push_str("        - bun run --enable-source-maps index-production.js\n");

    // Environment paths for runtime resolution
    if has_js_ts || has_python {
        config.push_str("\n      # Runtime environment paths\n");
        config.push_str("      env:\n");

        if has_js_ts {
            config.push_str(&format!(
                "        NODE_PATH: \"{}\"\n",
                node_modules_path.display()
            ));
        }

        if has_python {
            config.push_str(&format!(
                "        VIRTUAL_ENV: \"{}\"\n",
                venv_path.display()
            ));
            config.push_str(&format!(
                "        PYTHONPATH: \"{}/lib/python3.11/site-packages\"\n",
                venv_path.display()
            ));
        }
    }

    config.push_str("\n");

    // StreamModule for real-time data
    config.push_str("  # Real-time data streams\n");
    config.push_str("  - class: modules::streams::StreamModule\n");
    config.push_str("    config:\n");
    config.push_str(&format!("      port: {}\n", DEFAULT_STREAMS_PORT));
    config.push_str("      adapter:\n");
    config.push_str("        class: adapters::kv_store::KvStore\n");
    config.push_str("        config:\n");
    config.push_str("          storage_type: in_memory\n");
    config.push_str("\n");

    // RestApiModule for HTTP endpoints
    config.push_str("  # REST API endpoints\n");
    config.push_str("  - class: modules::api::RestApiModule\n");
    config.push_str("    config:\n");
    config.push_str(&format!("      port: {}\n", DEFAULT_API_PORT));
    config.push_str("      cors:\n");
    config.push_str("        enabled: true\n");
    config.push_str("        allow_origins:\n");
    config.push_str("          - \"*\"\n");
    config.push_str("\n");

    // LoggingModule
    config.push_str("  # Logging configuration\n");
    config.push_str("  - class: modules::observability::LoggingModule\n");
    config.push_str("    config:\n");
    config.push_str(&format!("      level: {}\n", DEFAULT_LOG_LEVEL));
    config.push_str("      adapter:\n");
    config.push_str("        class: adapters::logging::FileLogger\n");
    config.push_str("        config:\n");
    config.push_str("          path: ./logs\n");
    config.push_str("          format: json\n");

    config
}

/// Write the iii configuration to a file
pub async fn write_config(project_dir: &Path, selected_languages: &[Language]) -> Result<()> {
    let config_content = generate_config(project_dir, selected_languages);
    let config_path = project_dir.join("iii.yaml");

    fs::write(&config_path, config_content)
        .await
        .with_context(|| format!("Failed to write iii config to {}", config_path.display()))?;

    Ok(())
}

/// Get the default port configuration
pub fn get_default_ports() -> (u16, u16) {
    (DEFAULT_STREAMS_PORT, DEFAULT_API_PORT)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_config_typescript_only() {
        let dir = PathBuf::from("/test/project");
        let languages = vec![Language::TypeScript];

        let config = generate_config(&dir, &languages);

        assert!(config.contains("bun run --enable-source-maps index-production.js"));
        assert!(config.contains("NODE_PATH"));
        assert!(!config.contains("VIRTUAL_ENV"));
    }

    #[test]
    fn test_generate_config_with_python() {
        let dir = PathBuf::from("/test/project");
        let languages = vec![Language::TypeScript, Language::Python];

        let config = generate_config(&dir, &languages);

        assert!(config.contains("NODE_PATH"));
        assert!(config.contains("VIRTUAL_ENV"));
        assert!(config.contains("PYTHONPATH"));
    }

    #[test]
    fn test_generate_config_has_default_ports() {
        let dir = PathBuf::from("/test/project");
        let languages = vec![Language::TypeScript];

        let config = generate_config(&dir, &languages);

        // TODO: Port numbers should come from declarations above
        assert!(config.contains("port: 31112"));
        assert!(config.contains("port: 31113"));
    }
}
